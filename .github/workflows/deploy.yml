name: InterviewPro Production Deployment

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  SERVER_HOST: 3.138.194.143
  SERVER_USER: ec2-user
  DEPLOY_PATH: /home/ec2-user

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
        
    - name: Install dependencies
      run: |
        cd backend
        pip install -r requirements.txt
        
    - name: Run backend tests
      run: |
        cd backend
        python -m pytest tests/ --verbose || echo "Tests completed"
        
    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        
    - name: Install frontend dependencies
      run: |
        cd frontend
        npm ci
        
    - name: Build frontend
      run: |
        cd frontend
        npm run build
        
    - name: Run frontend tests
      run: |
        cd frontend
        npm test -- --coverage --watchAll=false || echo "Frontend tests completed"

  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'sarif'
        output: 'trivy-results.sarif'
        
    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v2
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'

  build:
    name: Build Docker Images
    runs-on: ubuntu-latest
    needs: [test, security-scan]
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Build backend image
      run: |
        cd backend
        docker build -f Dockerfile.prod -t interviewpro-backend:latest .
        
    - name: Build frontend image
      run: |
        cd frontend
        docker build -f Dockerfile.prod -t interviewpro-frontend:latest .
        
    - name: Save Docker images
      run: |
        docker save interviewpro-backend:latest | gzip > backend-image.tar.gz
        docker save interviewpro-frontend:latest | gzip > frontend-image.tar.gz
        
    - name: Upload backend image artifact
      uses: actions/upload-artifact@v3
      with:
        name: backend-image
        path: backend-image.tar.gz
        retention-days: 1
        
    - name: Upload frontend image artifact
      uses: actions/upload-artifact@v3
      with:
        name: frontend-image
        path: frontend-image.tar.gz
        retention-days: 1

  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build]
    if: github.ref == 'refs/heads/main'
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Download backend image
      uses: actions/download-artifact@v3
      with:
        name: backend-image
        
    - name: Download frontend image
      uses: actions/download-artifact@v3
      with:
        name: frontend-image
      
    - name: Setup SSH
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H ${{ env.SERVER_HOST }} >> ~/.ssh/known_hosts
        
    - name: Create deployment directory
      run: |
        ssh ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }} "mkdir -p ${{ env.DEPLOY_PATH }}/deployment"
        
    - name: Upload deployment files
      run: |
        scp docker-compose.prod.yml ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }}:${{ env.DEPLOY_PATH }}/
        scp nginx-https.conf ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }}:${{ env.DEPLOY_PATH }}/
        scp -r scripts/ ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }}:${{ env.DEPLOY_PATH }}/
        
    - name: Upload Docker images
      run: |
        scp backend-image.tar.gz ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }}:${{ env.DEPLOY_PATH }}/deployment/
        scp frontend-image.tar.gz ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }}:${{ env.DEPLOY_PATH }}/deployment/
        
    - name: Pre-deployment checks
      run: |
        ssh ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }} << 'EOF'
          cd ${{ env.DEPLOY_PATH }}
          
          # è¿è¡Œéƒ¨ç½²å‰æ£€æŸ¥
          if [ -f "scripts/deploy_checklist.sh" ]; then
            chmod +x scripts/deploy_checklist.sh
            ./scripts/deploy_checklist.sh
          fi
          
          # æ£€æŸ¥ç£ç›˜ç©ºé—´
          DISK_USAGE=$(df / | awk 'NR==2 {print $5}' | sed 's/%//')
          if [ "$DISK_USAGE" -gt 85 ]; then
            echo "âŒ ç£ç›˜ç©ºé—´ä¸è¶³: ${DISK_USAGE}%"
            exit 1
          fi
          
          # æ£€æŸ¥å†…å­˜
          MEMORY_USAGE=$(free | awk 'NR==2{printf "%.0f", $3/$2*100}')
          if [ "$MEMORY_USAGE" -gt 90 ]; then
            echo "âŒ å†…å­˜ä½¿ç”¨ç‡è¿‡é«˜: ${MEMORY_USAGE}%"
            exit 1
          fi
          
          echo "âœ… éƒ¨ç½²å‰æ£€æŸ¥é€šè¿‡"
        EOF
        
    - name: Backup current state
      run: |
        ssh ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }} << 'EOF'
          cd ${{ env.DEPLOY_PATH }}
          
          # å¤‡ä»½å½“å‰æ•°æ®åº“
          if [ -f "scripts/database_backup.sh" ]; then
            chmod +x scripts/database_backup.sh
            ./scripts/database_backup.sh
            echo "âœ… æ•°æ®åº“å¤‡ä»½å®Œæˆ"
          fi
          
          # å¤‡ä»½å½“å‰é…ç½®
          BACKUP_DIR="backup/$(date '+%Y-%m-%d_%H-%M-%S')"
          mkdir -p "$BACKUP_DIR"
          
          if [ -f "docker-compose.prod.yml" ]; then
            cp docker-compose.prod.yml "$BACKUP_DIR/"
          fi
          
          if [ -f "nginx-https.conf" ]; then
            cp nginx-https.conf "$BACKUP_DIR/"
          fi
          
          echo "âœ… é…ç½®å¤‡ä»½å®Œæˆ: $BACKUP_DIR"
        EOF
        
    - name: Load new Docker images
      run: |
        ssh ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }} << 'EOF'
          cd ${{ env.DEPLOY_PATH }}/deployment
          
          echo "ğŸ“¦ åŠ è½½æ–°çš„Dockeré•œåƒ..."
          docker load < backend-image.tar.gz
          docker load < frontend-image.tar.gz
          
          # é‡æ–°æ ‡è®°é•œåƒ
          docker tag interviewpro-backend:latest ec2-user-backend:latest
          docker tag interviewpro-frontend:latest ec2-user-frontend:latest
          
          echo "âœ… Dockeré•œåƒåŠ è½½å®Œæˆ"
        EOF
        
    - name: Deploy services
      run: |
        ssh ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }} << 'EOF'
          cd ${{ env.DEPLOY_PATH }}
          
          echo "ğŸš€ å¼€å§‹éƒ¨ç½²æœåŠ¡..."
          
          # ä½¿ç”¨åˆ†é˜¶æ®µéƒ¨ç½²
          if [ -f "scripts/deploy_staged.sh" ]; then
            chmod +x scripts/deploy_staged.sh
            ./scripts/deploy_staged.sh
          else
            # å›é€€åˆ°åŸºæœ¬éƒ¨ç½²
            docker-compose -f docker-compose.prod.yml down --remove-orphans
            docker-compose -f docker-compose.prod.yml up -d
          fi
          
          echo "âœ… æœåŠ¡éƒ¨ç½²å®Œæˆ"
        EOF
        
    - name: Post-deployment verification
      run: |
        ssh ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }} << 'EOF'
          cd ${{ env.DEPLOY_PATH }}
          
          echo "ğŸ” è¿›è¡Œéƒ¨ç½²åéªŒè¯..."
          
          # ç­‰å¾…æœåŠ¡å¯åŠ¨
          sleep 30
          
          # æ£€æŸ¥å®¹å™¨çŠ¶æ€
          UNHEALTHY_CONTAINERS=$(docker ps --filter "status=exited" --format "{{.Names}}" | grep -E "(mysql|redis|backend|nginx)" || echo "")
          
          if [ -n "$UNHEALTHY_CONTAINERS" ]; then
            echo "âŒ å‘ç°åœæ­¢çš„å®¹å™¨: $UNHEALTHY_CONTAINERS"
            exit 1
          fi
          
          # æ£€æŸ¥ç½‘ç«™å“åº”
          if curl -f -s "https://offerott.com" > /dev/null; then
            echo "âœ… ç½‘ç«™è®¿é—®æ­£å¸¸"
          else
            echo "âŒ ç½‘ç«™æ— æ³•è®¿é—®"
            exit 1
          fi
          
          # æ£€æŸ¥APIå“åº”
          if curl -f -s "https://offerott.com/api/v1/" > /dev/null; then
            echo "âœ… APIè®¿é—®æ­£å¸¸"
          else
            echo "âŒ APIæ— æ³•è®¿é—®"
            exit 1
          fi
          
          # æ£€æŸ¥æ•°æ®åº“è¿æ¥
          if docker exec interviewpro-mysql mysql -u user -p'password' -e "SELECT 1;" > /dev/null 2>&1; then
            echo "âœ… æ•°æ®åº“è¿æ¥æ­£å¸¸"
          else
            echo "âŒ æ•°æ®åº“è¿æ¥å¤±è´¥"
            exit 1
          fi
          
          echo "ğŸ‰ éƒ¨ç½²éªŒè¯æˆåŠŸï¼"
        EOF
        
    - name: Cleanup
      if: always()
      run: |
        ssh ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }} << 'EOF'
          cd ${{ env.DEPLOY_PATH }}
          
          # æ¸…ç†éƒ¨ç½²æ–‡ä»¶
          rm -rf deployment/
          
          # æ¸…ç†æ—§çš„Dockeré•œåƒ
          docker image prune -f
          
          echo "ğŸ§¹ æ¸…ç†å®Œæˆ"
        EOF
        
    - name: Send deployment notification
      if: always()
      run: |
        if [ "${{ job.status }}" = "success" ]; then
          echo "âœ… éƒ¨ç½²æˆåŠŸ! ç½‘ç«™: https://offerott.com"
        else
          echo "âŒ éƒ¨ç½²å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ—¥å¿—"
        fi
        
        # è¿™é‡Œå¯ä»¥æ·»åŠ Slack/é‚®ä»¶é€šçŸ¥
        # curl -X POST -H 'Content-type: application/json' \
        #   --data '{"text":"InterviewPro deployment ${{ job.status }}"}' \
        #   ${{ secrets.SLACK_WEBHOOK_URL }}

  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: [deploy]
    if: failure() && github.ref == 'refs/heads/main'
    
    steps:
    - name: Setup SSH for Rollback
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H ${{ env.SERVER_HOST }} >> ~/.ssh/known_hosts
        
    - name: Emergency Rollback
      run: |
        ssh ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }} << 'EOF'
          cd ${{ env.DEPLOY_PATH }}
          
          echo "ğŸ†˜ å¼€å§‹ç´§æ€¥å›æ»š..."
          
          # ä½¿ç”¨ç´§æ€¥æ¢å¤è„šæœ¬
          if [ -f "scripts/emergency_recovery.sh" ]; then
            chmod +x scripts/emergency_recovery.sh
            echo "7" | ./scripts/emergency_recovery.sh  # é€‰æ‹©å®Œæ•´æ¢å¤é€‰é¡¹
          else
            # æ‰‹åŠ¨å›æ»š
            echo "ğŸ“¦ å›æ»šåˆ°ä¸Šä¸€ä¸ªå·¥ä½œç‰ˆæœ¬..."
            
            # æ¢å¤æœ€æ–°çš„å¤‡ä»½é…ç½®
            LATEST_BACKUP=$(ls -td backup/*/ | head -1)
            if [ -n "$LATEST_BACKUP" ]; then
              cp "$LATEST_BACKUP"docker-compose.prod.yml . 2>/dev/null || true
              cp "$LATEST_BACKUP"nginx-https.conf . 2>/dev/null || true
            fi
            
            # é‡å¯æœåŠ¡
            docker-compose -f docker-compose.prod.yml down
            docker-compose -f docker-compose.prod.yml up -d
          fi
          
          echo "ğŸ”„ å›æ»šå®Œæˆï¼Œè¯·æ‰‹åŠ¨éªŒè¯æœåŠ¡çŠ¶æ€"
        EOF 