<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸš€ Abandoned Functionality Test</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
        }
        .container {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }
        .test-section {
            margin: 20px 0;
            padding: 20px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            background: #f8f9fa;
        }
        .test-section h3 {
            margin-top: 0;
            color: #495057;
        }
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px;
            transition: transform 0.2s;
        }
        button:hover {
            transform: translateY(-2px);
        }
        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
        }
        .result {
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
        }
        .success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        .warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 300px;
            overflow-y: auto;
        }
        .status-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
            text-transform: uppercase;
        }
        .status-abandoned { background: #dc3545; color: white; }
        .status-in_progress { background: #ffc107; color: #212529; }
        .status-ready { background: #28a745; color: white; }
        .status-created { background: #6c757d; color: white; }
        .status-completed { background: #17a2b8; color: white; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸš€ Abandoned Functionality Test</h1>
        <p>æµ‹è¯•é¢è¯•ä¼šè¯abandonedçŠ¶æ€çš„å®Œæ•´åŠŸèƒ½</p>

        <!-- æµ‹è¯•1: æŸ¥çœ‹å½“å‰çŠ¶æ€åˆ†å¸ƒ -->
        <div class="test-section">
            <h3>ğŸ“Š 1. å½“å‰é¢è¯•ä¼šè¯çŠ¶æ€åˆ†å¸ƒ</h3>
            <button onclick="checkStatusDistribution()">ğŸ” æŸ¥çœ‹çŠ¶æ€åˆ†å¸ƒ</button>
            <div id="statusResult"></div>
        </div>

        <!-- æµ‹è¯•2: æµ‹è¯•abandon API -->
        <div class="test-section">
            <h3>ğŸ›‘ 2. æµ‹è¯• Abandon API</h3>
            <button onclick="testAbandonAPI()">ğŸ§ª æµ‹è¯•AbandonåŠŸèƒ½</button>
            <div id="abandonResult"></div>
        </div>

        <!-- æµ‹è¯•3: æµ‹è¯•abandonedçŠ¶æ€çš„é™åˆ¶ -->
        <div class="test-section">
            <h3>ğŸš« 3. æµ‹è¯•AbandonedçŠ¶æ€é™åˆ¶</h3>
            <button onclick="testAbandonedRestrictions()">ğŸ”’ æµ‹è¯•çŠ¶æ€é™åˆ¶</button>
            <div id="restrictionResult"></div>
        </div>

        <!-- æµ‹è¯•4: å‰ç«¯abandonInterviewè°ƒç”¨ -->
        <div class="test-section">
            <h3>ğŸ’» 4. å‰ç«¯abandonInterviewè°ƒç”¨</h3>
            <button onclick="testFrontendAbandon()">ğŸ“± æµ‹è¯•å‰ç«¯è°ƒç”¨</button>
            <div id="frontendResult"></div>
        </div>

        <!-- æµ‹è¯•5: æ¨¡æ‹Ÿæµè§ˆå™¨å…³é—­åœºæ™¯ -->
        <div class="test-section">
            <h3>ğŸŒ 5. æµè§ˆå™¨å…³é—­æ£€æµ‹</h3>
            <button onclick="simulateBrowserClose()">ğŸ”„ æ¨¡æ‹Ÿæµè§ˆå™¨å…³é—­</button>
            <div id="browserResult"></div>
        </div>

        <div id="globalResults"></div>
    </div>

    <script>
        const API_BASE = 'http://localhost:5001/api/v1';
        let currentToken = null;

        // è·å–è®¤è¯token
        async function getAuthToken() {
            if (currentToken) return currentToken;
            
            try {
                const response = await fetch(`${API_BASE}/auth/login`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        email: '3938930977@qq.com',
                        password: '12345678'
                    })
                });
                const data = await response.json();
                currentToken = data.data.access_token;
                return currentToken;
            } catch (error) {
                console.error('ç™»å½•å¤±è´¥:', error);
                throw error;
            }
        }

        // æ˜¾ç¤ºç»“æœ
        function showResult(elementId, message, type = 'info') {
            const element = document.getElementById(elementId);
            const resultDiv = document.createElement('div');
            resultDiv.className = `result ${type}`;
            resultDiv.innerHTML = `<pre>${message}</pre>`;
            element.appendChild(resultDiv);
        }

        // æµ‹è¯•1: æŸ¥çœ‹çŠ¶æ€åˆ†å¸ƒ
        async function checkStatusDistribution() {
            try {
                const token = await getAuthToken();
                const response = await fetch(`${API_BASE}/interviews?page=1&per_page=100`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                const data = await response.json();
                
                if (data.success) {
                    const sessions = data.data.sessions;
                    const statusCount = {};
                    
                    sessions.forEach(session => {
                        statusCount[session.status] = (statusCount[session.status] || 0) + 1;
                    });
                    
                    let result = 'ğŸ“Š é¢è¯•ä¼šè¯çŠ¶æ€åˆ†å¸ƒ:\n';
                    Object.entries(statusCount).forEach(([status, count]) => {
                        result += `  ${status}: ${count} ä¸ª\n`;
                    });
                    result += `\næ€»è®¡: ${sessions.length} ä¸ªä¼šè¯`;
                    
                    showResult('statusResult', result, 'success');
                } else {
                    showResult('statusResult', `âŒ è·å–å¤±è´¥: ${data.message}`, 'error');
                }
            } catch (error) {
                showResult('statusResult', `âŒ è¯·æ±‚å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // æµ‹è¯•2: æµ‹è¯•abandon API
        async function testAbandonAPI() {
            try {
                const token = await getAuthToken();
                
                // é¦–å…ˆè·å–ä¸€ä¸ªin_progressçŠ¶æ€çš„ä¼šè¯
                const listResponse = await fetch(`${API_BASE}/interviews?page=1&per_page=20`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                const listData = await listResponse.json();
                
                const inProgressSession = listData.data.sessions.find(s => s.status === 'in_progress');
                
                if (!inProgressSession) {
                    showResult('abandonResult', 'âš ï¸ æ²¡æœ‰æ‰¾åˆ°in_progressçŠ¶æ€çš„ä¼šè¯è¿›è¡Œæµ‹è¯•', 'warning');
                    return;
                }
                
                // æµ‹è¯•abandon API
                const abandonResponse = await fetch(`${API_BASE}/interviews/${inProgressSession.session_id}/abandon`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ reason: 'test_abandon_api' })
                });
                
                const abandonData = await abandonResponse.json();
                
                if (abandonData.success) {
                    let result = `âœ… Abandon API æµ‹è¯•æˆåŠŸ!\n`;
                    result += `ä¼šè¯ID: ${inProgressSession.session_id}\n`;
                    result += `åŸçŠ¶æ€: ${inProgressSession.status} â†’ æ–°çŠ¶æ€: ${abandonData.data.session.status}\n`;
                    result += `æ”¾å¼ƒåŸå› : test_abandon_api\n`;
                    result += `å“åº”æ¶ˆæ¯: ${abandonData.message}`;
                    
                    showResult('abandonResult', result, 'success');
                } else {
                    showResult('abandonResult', `âŒ Abandonå¤±è´¥: ${abandonData.message}`, 'error');
                }
                
            } catch (error) {
                showResult('abandonResult', `âŒ æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // æµ‹è¯•3: æµ‹è¯•abandonedçŠ¶æ€çš„é™åˆ¶
        async function testAbandonedRestrictions() {
            try {
                const token = await getAuthToken();
                
                // è·å–ä¸€ä¸ªabandonedçŠ¶æ€çš„ä¼šè¯
                const listResponse = await fetch(`${API_BASE}/interviews?page=1&per_page=50`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                const listData = await listResponse.json();
                
                const abandonedSession = listData.data.sessions.find(s => s.status === 'abandoned');
                
                if (!abandonedSession) {
                    showResult('restrictionResult', 'âš ï¸ æ²¡æœ‰æ‰¾åˆ°abandonedçŠ¶æ€çš„ä¼šè¯è¿›è¡Œæµ‹è¯•', 'warning');
                    return;
                }
                
                let result = `ğŸ”’ æµ‹è¯•abandonedçŠ¶æ€é™åˆ¶ (ä¼šè¯ID: ${abandonedSession.session_id})\n\n`;
                
                // æµ‹è¯•1: å°è¯•å¯åŠ¨abandonedä¼šè¯
                try {
                    const startResponse = await fetch(`${API_BASE}/interviews/${abandonedSession.session_id}/start`, {
                        method: 'POST',
                        headers: { 'Authorization': `Bearer ${token}` }
                    });
                    const startData = await startResponse.json();
                    
                    if (startResponse.status === 400) {
                        result += `âœ… å¯åŠ¨é™åˆ¶æµ‹è¯•é€šè¿‡: ${startData.error.message}\n`;
                    } else {
                        result += `âŒ å¯åŠ¨é™åˆ¶æµ‹è¯•å¤±è´¥: åº”è¯¥è¿”å›400é”™è¯¯\n`;
                    }
                } catch (error) {
                    result += `âŒ å¯åŠ¨æµ‹è¯•å‡ºé”™: ${error.message}\n`;
                }
                
                // æµ‹è¯•2: å°è¯•æäº¤ç­”æ¡ˆåˆ°abandonedä¼šè¯
                try {
                    const submitResponse = await fetch(`${API_BASE}/interviews/${abandonedSession.session_id}/answers`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${token}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            question_id: 1,
                            answer_text: 'Test answer'
                        })
                    });
                    const submitData = await submitResponse.json();
                    
                    if (submitResponse.status === 400) {
                        result += `âœ… ç­”æ¡ˆæäº¤é™åˆ¶æµ‹è¯•é€šè¿‡: ${submitData.error.message}\n`;
                    } else {
                        result += `âŒ ç­”æ¡ˆæäº¤é™åˆ¶æµ‹è¯•å¤±è´¥: åº”è¯¥è¿”å›400é”™è¯¯\n`;
                    }
                } catch (error) {
                    result += `âŒ ç­”æ¡ˆæäº¤æµ‹è¯•å‡ºé”™: ${error.message}\n`;
                }
                
                showResult('restrictionResult', result, 'success');
                
            } catch (error) {
                showResult('restrictionResult', `âŒ æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // æµ‹è¯•4: å‰ç«¯abandonInterviewè°ƒç”¨
        async function testFrontendAbandon() {
            try {
                const token = await getAuthToken();
                
                // æ¨¡æ‹Ÿå‰ç«¯interviewService.abandonInterviewè°ƒç”¨
                const testSessionId = 'test-session-id';
                const reason = 'frontend_test';
                
                const response = await fetch(`${API_BASE}/interviews/${testSessionId}/abandon`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ reason: reason })
                });
                
                const data = await response.json();
                
                let result = `ğŸ’» å‰ç«¯abandonInterviewè°ƒç”¨æµ‹è¯•:\n`;
                result += `æµ‹è¯•ä¼šè¯ID: ${testSessionId}\n`;
                result += `æµ‹è¯•åŸå› : ${reason}\n`;
                result += `å“åº”çŠ¶æ€: ${response.status}\n`;
                
                if (response.status === 400 && data.error.message.includes('not found')) {
                    result += `âœ… APIè°ƒç”¨æ ¼å¼æ­£ç¡® (ä¼šè¯ä¸å­˜åœ¨æ˜¯é¢„æœŸçš„)\n`;
                    result += `é”™è¯¯æ¶ˆæ¯: ${data.error.message}`;
                    showResult('frontendResult', result, 'success');
                } else {
                    result += `å“åº”æ•°æ®: ${JSON.stringify(data, null, 2)}`;
                    showResult('frontendResult', result, 'info');
                }
                
            } catch (error) {
                showResult('frontendResult', `âŒ å‰ç«¯è°ƒç”¨æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // æµ‹è¯•5: æ¨¡æ‹Ÿæµè§ˆå™¨å…³é—­åœºæ™¯
        async function simulateBrowserClose() {
            try {
                const token = await getAuthToken();
                
                // è·å–ä¸€ä¸ªin_progressçŠ¶æ€çš„ä¼šè¯
                const listResponse = await fetch(`${API_BASE}/interviews?page=1&per_page=20`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                const listData = await listResponse.json();
                
                const inProgressSession = listData.data.sessions.find(s => s.status === 'in_progress');
                
                if (!inProgressSession) {
                    showResult('browserResult', 'âš ï¸ æ²¡æœ‰æ‰¾åˆ°in_progressçŠ¶æ€çš„ä¼šè¯è¿›è¡Œæµ‹è¯•', 'warning');
                    return;
                }
                
                // æ¨¡æ‹Ÿbeforeunloadäº‹ä»¶ä¸­çš„fetchè°ƒç”¨
                const response = await fetch(`${API_BASE}/interviews/${inProgressSession.session_id}/abandon`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ reason: 'browser_close' }),
                    keepalive: true // æ¨¡æ‹Ÿbeforeunloadä¸­çš„keepalive
                });
                
                const data = await response.json();
                
                let result = `ğŸŒ æµè§ˆå™¨å…³é—­æ£€æµ‹æµ‹è¯•:\n`;
                result += `æµ‹è¯•ä¼šè¯ID: ${inProgressSession.session_id}\n`;
                result += `æ¨¡æ‹Ÿåœºæ™¯: æµè§ˆå™¨å…³é—­/åˆ·æ–°\n`;
                result += `ä½¿ç”¨keepalive: true\n`;
                
                if (data.success) {
                    result += `âœ… æµè§ˆå™¨å…³é—­æ£€æµ‹æˆåŠŸ!\n`;
                    result += `ä¼šè¯çŠ¶æ€: ${inProgressSession.status} â†’ ${data.data.session.status}\n`;
                    result += `æ”¾å¼ƒåŸå› : browser_close`;
                    showResult('browserResult', result, 'success');
                } else {
                    result += `âŒ æµè§ˆå™¨å…³é—­æ£€æµ‹å¤±è´¥: ${data.message}`;
                    showResult('browserResult', result, 'error');
                }
                
            } catch (error) {
                showResult('browserResult', `âŒ æµè§ˆå™¨å…³é—­æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // é¡µé¢åŠ è½½æ—¶æ˜¾ç¤ºè¯´æ˜
        window.onload = function() {
            showResult('globalResults', 
                'ğŸš€ AbandonedåŠŸèƒ½æµ‹è¯•é¡µé¢å·²åŠ è½½\n' +
                'ğŸ“‹ æµ‹è¯•å†…å®¹:\n' +
                '  1. æŸ¥çœ‹å½“å‰é¢è¯•ä¼šè¯çŠ¶æ€åˆ†å¸ƒ\n' +
                '  2. æµ‹è¯•abandon APIçš„åŸºæœ¬åŠŸèƒ½\n' +
                '  3. éªŒè¯abandonedçŠ¶æ€çš„è®¿é—®é™åˆ¶\n' +
                '  4. æµ‹è¯•å‰ç«¯abandonInterviewè°ƒç”¨\n' +
                '  5. æ¨¡æ‹Ÿæµè§ˆå™¨å…³é—­åœºæ™¯\n\n' +
                'ğŸ‘† ç‚¹å‡»ä¸Šæ–¹æŒ‰é’®å¼€å§‹æµ‹è¯•å„é¡¹åŠŸèƒ½', 
                'info'
            );
        };
    </script>
</body>
</html> 